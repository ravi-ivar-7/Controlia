require('dotenv').config({ path: '../../../.env' });
const { MongoClient } = require('mongodb');
const logger = require('../../services/logs/winstonLogger');
const Docker = require('dockerode');
const docker = new Docker({ socketPath: '//./pipe/docker_engine' });


const jupyterServer = async (io, socket, data) => {
    const client = new MongoClient(process.env.MONGODB_URL);
    let container;
    try {
        const decodedToken = socket.decodedToken;
        await client.connect();
        const db = client.db("controlia");
        const usersCollection = db.collection('users');
        const user = await usersCollection.findOne({ userId: decodedToken.userId });

        if (!user) {
            io.to(socket.decodedToken.userId).emit('warn', { message: 'User not found' });

        }

        // Execute the Jupyter notebook server in the background using nohup and save logs to notebook.log
        const exec = await container.exec({
            Cmd: ['sh', '-c', `nohup jupyter notebook --no-browser --ip=0.0.0.0 --port=8888 --notebook-dir=${NOTEBOOK_DIR} --allow-root > /${NOTEBOOK_DIR}/notebook.log 2>&1 & echo $!`],
            AttachStdout: true,
            AttachStderr: true,
            Tty: false, // Tty should be false to capture the output
        });

        const stream = await exec.start({ hijack: true, stdin: true });

        // Capture the PID from the output
        stream.on('data', (data) => {
            const output = data.toString().replace(/[^\x20-\x7E]/g, '').trim();
            io.to(socket.decodedToken.userId).emit('data', { output });

            const pidMatch = output.match(/^\d+$/);
            if (pidMatch) {
                pid = parseInt(pidMatch[0], 10);
                console.log('Jupyter notebook server PID:', pid);
            }
        });

        // Wait for a short time to ensure the server starts properly
        await new Promise(resolve => setTimeout(resolve, 5000));

        // Read the log file to extract the URL and token
        const execLogs = await container.exec({
            Cmd: ['cat', `${NOTEBOOK_DIR}/notebook.log`],
            AttachStdout: true,
            AttachStderr: true,
            Tty: false,
        });

        const logStream = await execLogs.start({ hijack: true, stdin: true });

        logStream.on('data', (data) => {
            const output = data.toString();
            io.to(socket.decodedToken.userId).emit('data', { output });

            // Capture the URL and token from the logs
            const tokenMatch = output.match(/token=([a-f0-9]{32,})/);
            if (tokenMatch) {
                token = tokenMatch[1];
                io.to(socket.decodedToken.userId).emit('connectionInfo', { token });
                console.log('Jupyter notebook server token:', token);
            }

            const urlRegex = /http:\/\/127.0.0.1:\d+[^\s]*token=[a-f0-9]{32,}/g;
            const urlMatch = output.match(urlRegex);
            if (urlMatch) {
                url = `http://${process.env.HTTP_HOST}:${user.hostPort8888}/tree?token=${token}`;
                io.to(socket.decodedToken.userId).emit('connectionInfo', { url });
                console.log('Jupyter notebook server URL:', url);
            }
        });


        stream.on('error', (err) => {
            const error = err.toString().replace(/[^\x20-\x7E]/g, '').trim();
            console.error(error);
            io.to(socket.decodedToken.userId).emit('error', { error });
        });

        await new Promise((resolve) => {
            stream.on('end', resolve);
        });
        io.to(socket.decodedToken.userId).emit('data', { output: 'started...' });

    } catch (error) {
        logger.error(`ERROR STARTING JUPYTER SERVER: ${error}`);
        return io.to(socket.decodedToken.userId).emit('error', { message: 'An error occurred during server startup', details: error.toString() });
    } finally {
        await client.close();
    }
};

module.exports = { jupyterServer };



const containerId = user.containerId;
        const notebookDirectory = `/${user.userId}/notebooks`;
        container = docker.getContainer(containerId);